/*
  This command calls the mc-collect-keys command and uses the output to generate
  a multisig transaction. It generats a PS009 'approval transaction' to approve
  the write price update generated by the mc-update-tx.js command.

  PS009:
  https://github.com/Permissionless-Software-Foundation/specifications/blob/master/ps009-multisig-approval.md

  It then sends that unsigned multisig transaction to each of the Minting
  Council NFT holders. Once the Minting Council approves the update by broadcasting
  their multisig transaction, the write price for the PSFFPP will be updated.
*/

// Global npm libraries
import bitcore from '@chris.troutner/bitcore-lib-cash'
import RetryQueue from '@chris.troutner/retry-queue'
import fs from 'fs'

// Local libraries
import WalletUtil from '../lib/wallet-util.js'
import config from '../../config/index.js'
import McCollectKeys from './mc-collect-keys.js'
import MsgNostrSend from './msg-nostr-send.js'

// CONSTANTS
// const WRITE_PRICE_ADDR = 'bitcoincash:qqlrzp23w08434twmvr4fxw672whkjy0py26r63g3d'
const WRITE_PRICE_ADDR = 'bitcoincash:qrwe6kxhvu47ve6jvgrf2d93w0q38av7s5xm9xfehr' // test address

class McApproval {
  constructor () {
    // Encapsulate dependencies
    this.walletUtil = new WalletUtil()
    this.config = config
    this.retryQueue = new RetryQueue()
    this.mcCollectKeys = new McCollectKeys()
    this.bitcore = bitcore

    // Bind 'this' object to all subfunctions.
    this.run = this.run.bind(this)
    this.validateFlags = this.validateFlags.bind(this)
    this.getPublicKeys = this.getPublicKeys.bind(this)
    this.createMultisigWallet = this.createMultisigWallet.bind(this)
    this.createMultisigTx = this.createMultisigTx.bind(this)
    this.sendTxToMc = this.sendTxToMc.bind(this)
  }

  async run (flags) {
    try {
      this.validateFlags(flags)

      // Initialize the wallet.
      this.bchWallet = await this.walletUtil.instanceWallet(flags.name)
      await this.bchWallet.initialize()
      this.bchjs = this.bchWallet.bchjs

      // Initialize the PSFFPP library.
      this.psffpp = await this.walletUtil.instancePsffpp(this.bchWallet)

      // Look up the public keys for MC NFT holders.
      const keys = await this.retryQueue.addToQueue(this.getPublicKeys, {})
      console.log('keys: ', keys)

      // Generate a 50% + 1 multisig wallet.
      const walletObj = this.createMultisigWallet(keys)
      console.log(`wallet object: ${JSON.stringify(walletObj)}`)

      // Generate a PS009 approval transaction
      const txObj = await this.createMultisigTx(walletObj, flags)
      console.log('txObj: ', txObj)

      await this.sendTxToMc({ txObj, keys, flags })

      return true
    } catch (err) {
      console.error(err)
      return 0
    }
  }

  validateFlags (flags) {
    // Exit if wallet not specified.
    const name = flags.name
    if (!name || name === '') {
      throw new Error('You must specify a wallet name with the -n flag.')
    }

    // Exit if txid not specified.
    const txid = flags.txid
    if (!txid || txid === '') {
      throw new Error('You must specify a txid with the -t flag.')
    }

    // Exit if json not specified.
    const json = flags.json
    if (!json || json === '') {
      throw new Error('You must specify a json file with a message property, using the -j flag.')
    }

    return true
  }

  // Retrieve the public keys for all MC NFT holders.
  async getPublicKeys () {
    try {
      // Collect the NFT token IDs.
      // await this.mcCollectKeys.instanceWallet()
      this.mcCollectKeys.bchWallet = this.bchWallet
      const nfts = await this.mcCollectKeys.getNftsFromGroup()
      // console.log('nfts: ', nfts)

      // Get the address holding each NFT.
      const addrs = await this.mcCollectKeys.getAddrs(nfts)
      // console.log('addrs: ', addrs)

      // Get the public keys for each address holding an NFT.
      const { keys } = await this.mcCollectKeys.findKeys(addrs, nfts)

      return keys
    } catch (err) {
      console.error('Error in getPublicKeys()')
      throw err
    }
  }

  // Generate a P2SH multisignature wallet from the public keys of the NFT holders.
  createMultisigWallet (keyPairs) {
    try {
      // Isolate just an array of public keys.
      const pubKeys = []
      for (let i = 0; i < keyPairs.length; i++) {
        const thisPair = keyPairs[i]

        pubKeys.push(thisPair.pubKey)
      }

      // Determine the number of signers. It's 50% + 1
      const requiredSigners = Math.floor(pubKeys.length / 2) + 1

      // Multisig Address
      const msAddr = new bitcore.Address(pubKeys, requiredSigners)

      // Locking Script in hex representation.
      const scriptHex = new bitcore.Script(msAddr).toHex()

      const walletObj = {
        address: msAddr.toString(),
        scriptHex,
        publicKeys: pubKeys,
        requiredSigners
      }

      return walletObj
    } catch (err) {
      console.error('Error in createMultisigWallet()')
      throw err
    }
  }

  // Create a transaction to approve the P2WDB write price update TX.
  async createMultisigTx (walletObj, flags) {
    try {
      const updateTxid = flags.txid

      // Generate the OP_RETURN data
      const script = [
        this.bchjs.Script.opcodes.OP_RETURN,
        Buffer.from('APPROVE'),
        Buffer.from(updateTxid)
      ]

      // Compile the script array into a bitcoin-compliant hex encoded string.
      const opReturnData = this.bchjs.Script.encode(script)

      // Bitcore can mess up the OP_RETURN. So I generate an initial tx with
      // bch-js and pass the hex to Bitcore.
      const txBuilder = new this.bchjs.TransactionBuilder()
      txBuilder.addOutput(opReturnData, 0)
      const tx = txBuilder.transaction.buildIncomplete()
      const hex = tx.toHex()

      // Get UTXO information for the multisig address.
      const utxos = await this.bchWallet.getUtxos(walletObj.address)
      // console.log('utxos: ', utxos)

      // Grab the biggest BCH UTXO for spending.
      const utxoToSpend = this.bchWallet.bchjs.Utxo.findBiggestUtxo(utxos.bchUtxos)
      // console.log('utxoToSpend: ', utxoToSpend)

      if (!utxoToSpend) {
        const multisigWalletAddr = walletObj.address
        throw new Error(`Multisig wallet has no UTXOs. Fund it with a few cents of BCH: ${multisigWalletAddr}`)
      }

      // Repackage the UTXO for bitcore-lib-cash
      const utxo = {
        txid: utxoToSpend.tx_hash,
        outputIndex: utxoToSpend.tx_pos,
        address: walletObj.address,
        script: walletObj.scriptHex,
        satoshis: utxoToSpend.value
      }

      const chosenAddr = WRITE_PRICE_ADDR

      // Generate a multisignature transaction.
      const multisigTx = new this.bitcore.Transaction(hex)
        .from(utxo, walletObj.publicKeys, walletObj.requiredSigners)
        // Send 1000 sats back to the chosen address.
        .to(chosenAddr, 1000)
        .feePerByte(3)
        // Send change back to the multisig address
        .change(walletObj.address)

      // This unsigned transaction object is sent to all participants.
      const unsignedTxObj = multisigTx.toObject()

      // Save the unsigned tx object so that it can be used in the mc-finish command.
      // this.conf.set('p2wdb-price-tx', unsignedTxObj)

      return unsignedTxObj
    } catch (err) {
      console.error('Error in createMultisigTx(): ', err)
      throw err
    }
  }

  async sendTxToMc (inObj = {}) {
    try {
      const { txObj, keys, flags } = inObj

      // Instantiate the msg-nostr-send library.
      const msgNostrSend = new MsgNostrSend()

      // Save the data to an external file.
      const txData = JSON.stringify({ data: txObj })
      const filePath = './files/data.json'
      fs.writeFileSync(filePath, txData)

      // Loop through each address holding a Minting Council NFT.
      for (let i = 0; i < keys.length; i++) {
        const thisPair = keys[i]

        const publicKey = thisPair.pubKey
        const bchAddress = thisPair.addr
        console.log(`Sending multisig TX to ${bchAddress} and encrypting with public key ${publicKey}`)

        const now = new Date()

        // Generate a flags object for the msg-nostr-send command.
        const sendFlags = {
          addr: bchAddress,
          name: flags.name,
          msg: flags.json,
          subject: `Adjust Write Price on ${now.toLocaleDateString()}`,
          json: flags.json,
          data: 'data.json'
        }

        // Send the E2EE message with data to the current MC NFT holder.
        await this.retryQueue.addToQueue(msgNostrSend.run, sendFlags)
        console.log('\n\n')
      }

      return true
    } catch (err) {
      console.error('Error in sendTxToMc(): ', err)
      throw err
    }
  }
}

export default McApproval
